---
layout: post
title: Example Content
description: >
  OSID 시스템의 인증·인가 흐름과 라이선스 발급 관리 방안을 5분 브리핑 형식으로 정리합니다.
sitemap: false
hide_last_modified: true
---

# 인증·인가 & 라이선스 관리 (OSID 5분 브리핑)

**Presented To:** CAR ORDER & PRODUCTION TRACKING SYSTEM  
**팀 이름:** 오생이들  
**작성자:** 현정근

---

## 문제 정의 (WHY)

- **보안 리스크**
    - 권한 없는 Dealer가 주문·생산 정보에 접근 가능
    - 인증·인가 로직 복잡 → 유지보수 비용 상승
- **다중 사용자 역할 분리 필요**
    - Master(본사), Dealer(대리점), User(최종고객)마다 권한 분리
- **라이선스 관리 필요**
    - Master에게만 발급된 유효한 제품키(license) 있어야 대리점 등록·운영

---

## 해결 방법 & 기술 선택 (HOW)

| 옵션                  | 비용 | 확장성 | 보안성 |
|----------------------|:----:|:------:|:------:|
| **Spring Security + JWT** |  0  |   5    |   15   |
| **SESSION 기반 인증**     | 10  |   3    |   10   |

- **Spring Security + JWT**
    - Stateless: 서버에 인증 정보 비저장 → 수평 확장 자유
    - 모바일·API 제약 최소화, 토큰 내부에 권한·만료 정보 포함
- **SESSION 기반 인증**
    - Stateful: 세션 저장소 필요(스티키·클러스터링)
    - 장점: 세션 관리·만료 로직 프레임워크 내장
    - 단점: 대규모 시 부하·관리 비용 상승

→ **JWT 선택 이유**:
- Master·Dealer·User가 여러 인스턴스에서 인증 → Stateless 필수
- CORS·쿠키 제약 최소화
- 토큰 자체 검증으로 빠르고 가벼운 인증 가능

---

## 아키텍처 & 데이터 모델 (WHAT)

```mermaid
flowchart LR
    subgraph Client
      U[User / Dealer / Master]
    end
    subgraph Server
      F[JwtAuthenticationFilter]
      I1[ApiLoggingInterceptor]
      I2[LicenseValidationInterceptor]
      C[Controller]
      S[Service]
      R[Repository]
      DB[(Database)]
    end
    U -->|로그인 요청| F
    F --> UTI[JwtUtil.validateToken()]
    UTI --> CUDS[CustomUserDetailsService]
    CUDS --> SC[SecurityContextHolder]
    F --> I1 --> I2 --> C --> S --> R --> DB
